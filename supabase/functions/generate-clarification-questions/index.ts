import { createClient } from "jsr:@supabase/supabase-js@2";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

Deno.serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { ideaId, ideaContent } = await req.json();

    if (!ideaId || !ideaContent) {
      throw new Error('ideaId and ideaContent are required');
    }

    // Create Supabase client with auth
    const authHeader = req.headers.get('Authorization');
    if (!authHeader) {
      throw new Error('Missing authorization header');
    }

    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      { global: { headers: { Authorization: authHeader } } }
    );

    // Verify user is authenticated
    const { data: { user }, error: userError } = await supabase.auth.getUser();
    if (userError || !user) {
      throw new Error('Unauthorized');
    }

    console.log('Generating clarification questions for idea:', ideaId);

    // Call Lovable AI to generate personalized questions
    const LOVABLE_API_KEY = Deno.env.get('LOVABLE_API_KEY');
    if (!LOVABLE_API_KEY) {
      throw new Error('LOVABLE_API_KEY not configured');
    }

    const systemPrompt = `You are an AI analyst for Kick Inn, a venture creation platform. Your role is to ask 3-4 targeted clarification questions that will help validate a business idea.

Focus on:
1. Target audience specificity (who exactly experiences this problem?)
2. Problem frequency and scale (how often, how many people?)
3. Existing solutions and differentiation (what's been tried, why isn't it working?)
4. Market opportunity (is this local, regional, or global?)

Generate questions that are:
- Specific and actionable
- Easy to understand for non-technical users
- Designed to extract quantifiable or concrete information
- Each question should include a brief helper text to guide the answer

Return ONLY a JSON array with this exact structure:
[
  {
    "id": "q1",
    "question": "The main question text",
    "helperText": "Brief guidance on what kind of answer is expected"
  }
]`;

    const userPrompt = `Analyze this business idea submission and generate 3-4 clarification questions:

${ideaContent}

Remember: Questions should help validate market depth, urgency, and uniqueness. Keep them conversational but specific.`;

    const aiResponse = await fetch('https://ai.gateway.lovable.dev/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${LOVABLE_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'google/gemini-2.5-flash',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.7,
      }),
    });

    if (!aiResponse.ok) {
      const errorText = await aiResponse.text();
      console.error('AI API error:', aiResponse.status, errorText);
      
      if (aiResponse.status === 429) {
        throw new Error('AI rate limit exceeded. Please try again in a moment.');
      }
      if (aiResponse.status === 402) {
        throw new Error('AI credits depleted. Please contact support.');
      }
      throw new Error('Failed to generate questions');
    }

    const aiData = await aiResponse.json();
    const generatedContent = aiData.choices[0]?.message?.content;

    if (!generatedContent) {
      throw new Error('No content generated by AI');
    }

    console.log('AI generated content:', generatedContent);

    // Parse AI response
    let questions;
    try {
      // Try to extract JSON from markdown code blocks if present
      const jsonMatch = generatedContent.match(/```(?:json)?\s*(\[[\s\S]*?\])\s*```/);
      const jsonStr = jsonMatch ? jsonMatch[1] : generatedContent;
      questions = JSON.parse(jsonStr);
    } catch (parseError) {
      console.error('Failed to parse AI response:', parseError);
      // Fallback to default questions if AI parsing fails
      questions = [
        {
          id: 'q1',
          question: 'Who feels this problem most?',
          helperText: 'Be specific about the target audience (e.g., "small business owners with 5-10 employees" not just "businesses")'
        },
        {
          id: 'q2',
          question: 'How often does this problem occur?',
          helperText: 'Give specific frequency: daily, weekly, or seasonal? Include rough estimates if possible.'
        },
        {
          id: 'q3',
          question: 'What solutions have been tried before, and why do they fall short?',
          helperText: 'List existing alternatives or workarounds and explain what makes them inadequate.'
        }
      ];
    }

    // Ensure questions have the right structure
    questions = questions.map((q: any, idx: number) => ({
      id: q.id || `q${idx + 1}`,
      question: q.question || '',
      helperText: q.helperText || q.helper_text || ''
    }));

    // Save to database
    const { data: clarification, error: dbError } = await supabase
      .from('idea_clarifications')
      .insert({
        idea_id: ideaId,
        user_id: user.id,
        questions,
        status: 'pending'
      })
      .select()
      .single();

    if (dbError) {
      console.error('Database error:', dbError);
      throw new Error(`Failed to save questions: ${dbError.message}`);
    }

    console.log('Clarification questions saved successfully');

    return new Response(
      JSON.stringify({ 
        success: true, 
        clarification 
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200 
      }
    );

  } catch (error) {
    console.error('Error in generate-clarification-questions:', error);
    return new Response(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Unknown error' 
      }),
      { 
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500 
      }
    );
  }
});
